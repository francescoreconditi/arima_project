## Forecast {#sec-forecast}

### Previsioni del Modello

```{python}
#| label: forecast-analysis
#| fig-cap: "Andamento delle Previsioni con Intervalli di Confidenza"

forecast_data = model_results.get('forecast', {})
forecast_note = model_results.get('forecast_note', '')

if forecast_data and 'values' in forecast_data:
    # Abbiamo dati di forecast
    forecast_values = forecast_data['values']
    forecast_index = forecast_data.get('index', list(range(len(forecast_values))))
    steps = forecast_data.get('steps', len(forecast_values))
    confidence_level = forecast_data.get('confidence_level', 0.95)
    
    # Crea tabella dei risultati (converte stringhe in float se necessario)
    forecast_values = [float(val) if isinstance(val, str) else val for val in forecast_values]
    forecast_df = pd.DataFrame({
        'Periodo': forecast_index,
        'Valore Previsto': [f"{val:.2f}" for val in forecast_values]
    })
    
    # Aggiungi intervalli di confidenza se disponibili
    if 'confidence_intervals' in forecast_data:
        conf_int = forecast_data['confidence_intervals']
        lower_vals = [float(val) if isinstance(val, str) else val for val in conf_int['lower']]
        upper_vals = [float(val) if isinstance(val, str) else val for val in conf_int['upper']]
        forecast_df['Limite Inferiore'] = [f"{val:.2f}" for val in lower_vals]
        forecast_df['Limite Superiore'] = [f"{val:.2f}" for val in upper_vals]
    
    from IPython.display import HTML, display
    # Crea header HTML invece di usare print
    header_html = f"<h4>Tabella Previsioni ({steps} periodi)</h4>"
    html_table = forecast_df.to_html(index=False, classes='table table-striped', escape=False, table_id='forecast-table')
    # Combina header e tabella
    full_html = header_html + html_table
    display(HTML(full_html))
    
    # Crea grafico delle previsioni
    try:
        fig, ax = plt.subplots(figsize=(12, 6))
        
        # Plot dei valori previsti
        x_pos = list(range(len(forecast_values)))
        ax.plot(x_pos, forecast_values, 'ro-', linewidth=2, markersize=6, label=f'Previsioni', color='red')
        
        # Plot degli intervalli di confidenza se disponibili
        if 'confidence_intervals' in forecast_data:
            conf_int = forecast_data['confidence_intervals']
            lower_vals = [float(val) if isinstance(val, str) else val for val in conf_int['lower']]
            upper_vals = [float(val) if isinstance(val, str) else val for val in conf_int['upper']]
            ax.fill_between(x_pos, lower_vals, upper_vals, 
                           alpha=0.3, color='red', label=f'Intervallo {confidence_level:.0%}')
        
        ax.set_title(f'Previsioni del Modello - {steps} Periodi Futuri', fontsize=14, fontweight='bold')
        ax.set_xlabel('Periodo')
        ax.set_ylabel('Valore Previsto')
        ax.grid(True, alpha=0.3)
        ax.legend()
        
        # Aggiungi etichette sui punti
        for i, (x, y) in enumerate(zip(x_pos, forecast_values)):
            if i % max(1, len(x_pos)//10) == 0:  # Mostra ogni 10° etichetta per evitare sovraffollamento
                ax.annotate(f'{y:.1f}', (x, y), textcoords="offset points", xytext=(0,10), ha='center', fontsize=8)
        
        plt.xticks(x_pos[::max(1, len(x_pos)//10)], 
                  [str(idx) for idx in forecast_index[::max(1, len(x_pos)//10)]], 
                  rotation=45)
        plt.tight_layout()
        plt.show()
        
        # Statistiche delle previsioni
        display(HTML("<h4>Statistiche Previsioni</h4>"))
        stats_data = [
            ['Valore Medio Previsto', f"{np.mean(forecast_values):.2f}"],
            ['Valore Minimo', f"{np.min(forecast_values):.2f}"],
            ['Valore Massimo', f"{np.max(forecast_values):.2f}"],
            ['Deviazione Standard', f"{np.std(forecast_values):.2f}"]
        ]
        
        if 'confidence_intervals' in forecast_data:
            conf_int = forecast_data['confidence_intervals']
            lower_vals = [float(val) if isinstance(val, str) else val for val in conf_int['lower']]
            upper_vals = [float(val) if isinstance(val, str) else val for val in conf_int['upper']]
            avg_interval_width = np.mean(np.array(upper_vals) - np.array(lower_vals))
            stats_data.append(['Larghezza Media Intervallo', f"{avg_interval_width:.2f}"])
        
        stats_df = pd.DataFrame(stats_data, columns=['Statistica', 'Valore'])
        html_table = stats_df.to_html(index=False, classes='table table-striped', escape=False, table_id='forecast-stats')
        display(HTML(html_table))
        
    except Exception as e:
        display(HTML(f"<p class='text-danger'>Impossibile generare grafico delle previsioni: {e}</p>"))
        
elif forecast_note:
    # Abbiamo una nota sul perché il forecast non è disponibile
    display(HTML("<h4>Nota sulle Previsioni</h4>"))
    display(HTML(f"<p class='text-warning'>⚠️ {forecast_note}</p>"))
    
    # Se è un modello SARIMAX, fornisci suggerimenti
    model_type = model_results.get('model_type', '')
    if 'SARIMAX' in model_type:
        display(HTML("<p><strong>Suggerimento per modelli SARIMAX:</strong></p>"))
        display(HTML("<ul><li>I modelli SARIMAX richiedono variabili esogene future per generare previsioni</li>"))
        display(HTML("<li>Assicurati di fornire i valori futuri delle variabili esogene utilizzate durante l'addestramento</li></ul>"))
        if 'exog_names' in model_results:
            exog_names = model_results['exog_names']
            display(HTML(f"<p>- Variabili esogene richieste: {', '.join(exog_names)}</p>"))
else:
    display(HTML("<h4>Previsioni Non Disponibili</h4>"))
    display(HTML("<p>I dati di previsione non sono stati generati per questo modello.</p>"))
```

### Variabili Esogene (solo per modelli SARIMAX)

```{python}
#| label: exogenous-variables
#| tbl-cap: "Variabili Esogene Utilizzate"

model_type = model_results.get('model_type', '')
exog_names = model_results.get('exog_names', [])

if 'SARIMAX' in model_type and exog_names:
    display(HTML(f"<h4>Variabili Esogene Utilizzate nel Modello {model_type}</h4>"))
    
    exog_df = pd.DataFrame({
        'Variabile': exog_names,
        'Descrizione': [f"Variabile esogena {i+1}" for i in range(len(exog_names))]
    })
    
    from IPython.display import HTML, display
    html_table = exog_df.to_html(index=False, classes='table table-striped', escape=False, table_id='exog-vars-table')
    display(HTML(html_table))
    
    display(HTML(f"<p><strong>Numero totale di variabili esogene:</strong> {len(exog_names)}</p>"))
    display(HTML("<p><strong>Importanza delle Variabili Esogene:</strong></p>"))
    display(HTML("<p>Le variabili esogene forniscono informazioni aggiuntive al modello che possono migliorare l'accuratezza delle previsioni. Queste variabili rappresentano fattori esterni che influenzano la serie temporale ma non sono predetti dal modello stesso.</p>"))

elif 'SARIMAX' in model_type and not exog_names:
    display(HTML("<p class='text-warning'>⚠️ Modello SARIMAX configurato ma nessuna variabile esogena rilevata.</p>"))
    
else:
    display(HTML("<p>Questo modello non utilizza variabili esogene.</p>"))
```

---

*Report generato automaticamente dalla libreria ARIMA Forecaster*